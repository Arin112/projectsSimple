<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: Что это?</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md__d_1_denis_git_projects_simple__q_n_x_lab2__r_e_a_d_m_e.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Что это? </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Здесь покоится исходный код двух приложений под ОСРВ QNX. Клиент - lab1.cpp, interface.h, func.cpp и менеджер ресурсов QNX - <a class="el" href="lab2_8cpp.html">lab2.cpp</a>, interface.h. Клиент(модификация <a href="https://github.com/Arin112/projectsSimple/tree/master/QNX/lab1">первой лабы</a>) умеет шифровать файлы при помощи шифра Вермана, для этого ему нужно уметь получать ПСП (Псевдо Случайную Последовательность), это он делает при помощи сервера, который монтируется в /dev/LCG и откликается на запрос devctl со структурой описанной в interface.h. Более подробно требования описаны преподавателем - ТЗ лежит в файле ТЗ.doc. Выполнение требований описано в последующих главах. Начнём с самого главного - с тестирования. </p><h2>Тестирование</h2>
<p>Создадим файлик с названием script в папке /tmp с таким содержимым </p><div class="fragment"><div class="line">! rm -f in out key file decrypted</div><div class="line">! echo &quot;before script:\n&quot;</div><div class="line">! ls</div><div class="line">create in 20 # create file with 20 symbols</div><div class="line">crypt in out key # crypt in file with new key file and put res into out file</div><div class="line">decrypt out decrypted key # decrypt out file with key file</div><div class="line">! echo &quot;\nafter script:\n&quot;</div><div class="line">! ls</div><div class="line">! echo &quot;\nin file : $(cat in)\n&quot;</div><div class="line">! echo &quot;out file : $(cat out)\n&quot;</div><div class="line">! echo &quot;key file : $(cat key)\n&quot;</div><div class="line">! echo &quot;decrypded file : $(cat decrypted)\n&quot;</div><div class="line">! diff -s in decrypted</div><div class="line">! echo now let\&#39;s try big file</div><div class="line">create in 50000</div><div class="line">crypt in out key</div><div class="line">decrypt out decrypted key</div><div class="line">! wc -h -c in key out decrypted</div><div class="line">! diff -s in decrypted</div><div class="line"></div><div class="line">! rm -f lab1.x</div><div class="line">selfCopyTo lab1.x</div><div class="line">create inOne 10000000</div><div class="line">! wc -h -c inOne</div><div class="line">! echo &quot;crypt inOne outOne keyOne\nexit\n&quot; &gt;temp.script</div><div class="line">! echo &quot;./lab1.x &lt;temp.script&quot; &gt;temp.sh</div><div class="line">! rm -f outOne keyOne</div><div class="line">! echo time of crypting 10000000 bytes in one file</div><div class="line">! time sh temp.sh</div><div class="line">decrypt outOne decryptOne keyOne</div><div class="line">! diff -s inOne decryptOne</div><div class="line">! rm -f inOne keyOne outOne decryptOne</div><div class="line"></div><div class="line">create in1 10000000</div><div class="line">create in2 10000000</div><div class="line">create in3 10000000</div><div class="line">create in4 10000000</div><div class="line">! wc -h -c in?</div><div class="line">! rm -f key*</div><div class="line">! echo &quot;crypt in1 out1 key1\nexit\n&quot; &gt;temp1.script</div><div class="line">! echo &quot;crypt in2 out2 key2\nexit\n&quot; &gt;temp2.script</div><div class="line">! echo &quot;crypt in3 out3 key3\nexit\n&quot; &gt;temp3.script</div><div class="line">! echo &quot;crypt in4 out4 key4\nexit\n&quot; &gt;temp4.script</div><div class="line">! echo &quot;./lab1.x &lt;temp1.script &gt;err1 2&gt;&amp;1 &amp;\n&quot; &gt;temp.sh</div><div class="line">! echo &quot;./lab1.x &lt;temp2.script &gt;err2 2&gt;&amp;1 &amp;\n&quot; &gt;&gt;temp.sh</div><div class="line">! echo &quot;./lab1.x &lt;temp3.script &gt;err3 2&gt;&amp;1 &amp;\n&quot; &gt;&gt;temp.sh</div><div class="line">! echo &quot;./lab1.x &lt;temp4.script &gt;err4 2&gt;&amp;1 \n&quot; &gt;&gt;temp.sh</div><div class="line">! echo &quot;wait\n&quot; &gt;&gt;temp.sh</div><div class="line">! echo &quot;time of crypting 40000000 bytes in 4 files (10000000 bytes each)&quot;</div><div class="line">! time sh temp.sh</div><div class="line">! echo dectypring ...</div><div class="line">decrypt out1 decrypt1 key1</div><div class="line">decrypt out2 decrypt2 key2</div><div class="line">decrypt out3 decrypt3 key3</div><div class="line">decrypt out4 decrypt4 key4</div><div class="line">! diff -s in1 decrypt1</div><div class="line">! diff -s in2 decrypt2</div><div class="line">! diff -s in3 decrypt3</div><div class="line">! diff -s in4 decrypt4</div><div class="line">! rm -f in? key? out? decrypt?</div><div class="line">! echo done</div><div class="line">exit # close program</div></div><!-- fragment --><p> Со времён предыдущей лабы запускать его стало проще! Достаточно выполнить <code>self &lt;script</code> в клиенте. Можно, конечно, и просто копировать весь скрипт прямо в консоль самого momentics'a, почти одно и то же. Скрипт делает следующее - для начала воспроизводит первую лабораторную работу, создвая файл на 20 байт, шифрует и дешифрует его. Это проверяет минимальную работоспособность и самой первой лабы и менеджера ресурсов. После этого пробуем файл побольше - 50000 байт, для этого потребуется множество вызовов devctl, ведь он передаёт только по 4096 байт. Проверим размеры результирующий файлов при помощи <code>wc</code>, а совпадение входного и расшифрованного файлов при помощи <code>diff -s</code>. Теперь подготовимся к более сложной задаче - нужно засекать время выполнения команды шифрования. Делать это будем попутно с двойным фляком через левое ухо для единообразия с тестированием будущей многопоточности. Создаём файл temp.script с содержимым </p><div class="fragment"><div class="line">crypt inOne outOne keyOne</div><div class="line">exit</div></div><!-- fragment --><p> <code>selfCopyTo lab1.x</code> - копируем самого себя в lab1.x <code>! echo "./lab1.x &lt;temp.script" &gt;temp.sh</code> - создаём файл temp.sh для запуска lab1.x с перенаправлением стандартного ввода из файла temp.script. И запускаем с отсчётом времени <code>! time sh temp.sh</code> - команта time скажет время выполнения. После этого расшифровываем файл и убеждаемся, что он совпадает с оригиналом. Теперь нужно повторить процедуру, но уже запуская 4 копии программы одновременно для тестирования того, как поведёт себя менеджер ресурсов. За последующий скрипт необходимо оправдаться. Первое - я писать циклы в шелле QNX'а больно, так как он поддерживает далеко не все фичи bash'а. Второе - данный скрипт долгое время переписывался в надежде, что именно в нём находится один интересный баг(что оказалось неверно) и переписывать его снова в нормальное состояние у меня нет желания. Коротко - смысл тот же самый, создаётся на этот раз 4 входных файла, для каждого создаётся скрипт с командой его шифрования, после этого создаётся файл с temp.sh с содержимым </p><div class="fragment"><div class="line">./lab1.x &lt;temp1.script &gt;err1 2&gt;&amp;1 &amp;</div><div class="line">./lab1.x &lt;temp2.script &gt;err2 2&gt;&amp;1 &amp;</div><div class="line">./lab1.x &lt;temp3.script &gt;err3 2&gt;&amp;1 &amp;</div><div class="line">./lab1.x &lt;temp4.script &gt;err4 2&gt;&amp;1 </div><div class="line">wait</div></div><!-- fragment --><p> Который запускает параллельно 4 копии lab1.x со специально подготовленными для них скриптами и ждёт их завершения. После этого уже своей копией дешифруем файлы и проверяем совпадение оригинальных и расшифрованных файлов.</p>
<p>Такой вывод показывает запуск на моём пылесосе: </p><div class="fragment"><div class="line">before script:</div><div class="line"></div><div class="line">clean.sh                               script</div><div class="line">err1                                   temp.script</div><div class="line">err2                                   temp.sh</div><div class="line">err3                                   temp1.script</div><div class="line">err4                                   temp2.script</div><div class="line">lab1.x                                 temp3.script</div><div class="line">lab1Denis1553802313088136              temp4.script</div><div class="line">lab1Denis1553811155457150              testScript</div><div class="line">lab2Denis1553807001661147              timings1.sh</div><div class="line">oneFile.cr</div><div class="line"></div><div class="line">after script:</div><div class="line"></div><div class="line">clean.sh                               oneFile.cr</div><div class="line">decrypted                              out</div><div class="line">err1                                   script</div><div class="line">err2                                   temp.script</div><div class="line">err3                                   temp.sh</div><div class="line">err4                                   temp1.script</div><div class="line">in                                     temp2.script</div><div class="line">key                                    temp3.script</div><div class="line">lab1.x                                 temp4.script</div><div class="line">lab1Denis1553802313088136              testScript</div><div class="line">lab1Denis1553811155457150              timings1.sh</div><div class="line">lab2Denis1553807001661147</div><div class="line"></div><div class="line">in file : btjizdkdhoyhuyn qcgl</div><div class="line"></div><div class="line">out file : 4шR‹Ѓзn?»#ktіЗд•7</div><div class="line"></div><div class="line">key file : Vg’;nпкѓчВK“¶‡т[</div><div class="line"></div><div class="line">decrypded file : btjizdkdhoyhuyn qcgl</div><div class="line"></div><div class="line">Files in and decrypted are identical</div><div class="line">now let&#39;s try big file</div><div class="line">    bytes file</div><div class="line">    50000 in</div><div class="line">    50000 key</div><div class="line">    50000 out</div><div class="line">    50000 decrypted</div><div class="line">   200000 total</div><div class="line">Files in and decrypted are identical</div><div class="line">    bytes file</div><div class="line"> 10000000 inOne</div><div class="line">time of crypting 10000000 bytes in one file</div><div class="line">    1.78s real     0.69s user     0.03s system</div><div class="line">Files inOne and decryptOne are identical</div><div class="line">    bytes file</div><div class="line"> 10000000 in1</div><div class="line"> 10000000 in2</div><div class="line"> 10000000 in3</div><div class="line"> 10000000 in4</div><div class="line"> 40000000 total</div><div class="line">time of crypting 40000000 bytes in 4 files (10000000 bytes each)</div><div class="line">    9.26s real     4.12s user     0.22s system</div><div class="line">dectypring ...</div><div class="line">Files in1 and decrypt1 are identical</div><div class="line">Files in2 and decrypt2 are identical</div><div class="line">Files in3 and decrypt3 are identical</div><div class="line">Files in4 and decrypt4 are identical</div><div class="line">done</div></div><!-- fragment --><p> Можно было бы предположить, что время работы во втором случае должно не намного превышать время работы в первом, но это не так. Это говорит о том, что узкое место заключается не в долгом ожидании ПСП. Глядя на исподный код можно предположить, что узкое место - однопоточное копирование, причём неоднократное. Об это говорит и загрузка процессора, которая почти всегда находится на уровне одного ядра, в отличии от изначальной версии первой лабораторной работы. Тем не менее, тестирование можно считать успешным, менеджер ресурсов в несколько потоков обрабатывает сообщения от нескольких клиентов, верно выдавая необходимую ПСП, при этом и шифрование методом Вермана работает успешно. Избавиться от этого копирования можно, но учитывая требования ТЗ к интерфейсу и вообще использование devctl это просто приведёт к тому, что вся программа будет написана на Си. Не люблю Си. Поэтому это не сделано.</p>
<h2>Задача</h2>
<ol type="1">
<li>Реализовать функцию devctl в разрабатываемом АР, предусмотрев вызов на клиентской стороне.(1) Включить в реализацию клиента и сервера общий заголовочный интерфейсный файл.(2) Убедиться, что функция на сервере вызывается при поступлении сообщений от клиента.(3)<ol type="a">
<li>Функция io_devctl описана в файле lab1.cpp.</li>
<li>Файл interface.h.</li>
<li>Это происходит за счёт проверок на стороне клиента.</li>
</ol>
</li>
<li>Реализовать в серверном коде функцию генерации ПСП с помощью ЛКМ. Функция должна принимать на вход параметры начального состояния (seed): модуль, множитель, приращение и нулевой элемент ПСП, а также размер генерируемой ПСП. Функция должна возвращать полученную ПСП в виде POD динамического массива.<ul>
<li>Что подразумевается под "POD динамическим массивом", вообще говоря, не ясно. Но функция genLCG это делает. Зачем-то. Хотя нет, с описанным интерфейсом всё ясно. Это нужно только для лишнего копирования. Пусть будет.</li>
</ul>
</li>
<li>Предусмотреть ограничения на размер максимально возможной последовательности (с обоснованием этого размера), либо организовать обмен через многосоставный input-output вектор.<ul>
<li>Избран промежуточный вариант. Потому что нет никакого смысла заморачиваться с многосоставным вектором, учитвая, что обмен ПСП вообще не должен осуществлятся при помощи devctl(см. пункт Контрольные вопросы 3.2). В качестве максимального размера ПСП выбрано число 4096 как максимальная степень двойки не вызывающая "Server fault on msg pass". При внимательном чтении документации может сложиться впечатление, что максимальный размер сообщения составляет 2^14 - 1, но это не так, ведь есть ещё resmgr_attr.msg_max_size(установлено в 8192). Под промежуточным вариантом понимается следующий алгоритм : если требуемый размер ПСП меньше 4096, то достаточно обычного вызова devctl, в противном случае клиент вызывает devctl, после этого копирует полученную ПСП, при этом сервер обновляет значение x0 в переданных параметрах ЛКМ, что позволяет клиенту сразу же вызвать devctl снова, продолжая генерацию ПСП с того места, на котором сервер остановился. Затем клиент снова копирует полученную ПСП и цикл повторяется пока не будет сгенерирована ПСП нужной длинны. Процесс реализован в функции getLCG в файле lab1.cpp. Выбор пал именно на такой алгоритм по следующим причинам.<ol type="a">
<li>devctl не способен передавать большие объёмы данных, хотя механизм обмена сообщениями в QNX в теории может передавать данные размером до 2^31-1.</li>
<li>Нежеление использовать devctlv, так как в ТЗ дан пример именно devctl.</li>
<li>Использование двух типов сообщений для установки параметров ЛКМ и чтения ПСП крайне затруднительно в условиях многопоточной работы с несколькими клиентами. Даже просто в условиях работы с несколькими клиентами.</li>
</ol>
</li>
</ul>
</li>
<li>Реализовать команду devctl для генерации ПСП с помощью ЛКМ. Команда должна передавать(?) данные (начальные параметры генератора и размер ПСП) и возвращать клиенту ПСП(1). Для обмена данными реализовать структуру, прототип которой должен быть объявлен в интерфейсном файле(2).<ul>
<li>(?) - по всей виидмости принимать, а не передавать. Иначе не ясно, речь идёт в данном моменте про клиент или про сервер.</li>
</ul>
<ol type="a">
<li>io_devctl в <a class="el" href="lab2_8cpp.html">lab2.cpp</a> этим и занимается.</li>
<li>Файл interface.h, структура LCG.</li>
</ol>
</li>
<li>Протестировать полученный АР посредством вызова с клиентской стороны(1), передачи данных, контроля корректности получения данных сервером и возвращения ПСП клиенту(2), в роли которого выступает программа, разработанная в результате выполнения Лабораторной Работы 1(3).<ol type="a">
<li>См. главу Тестирование.</li>
<li>И в коде клиента, и в коде сервера есть проверки возвращемых значений требуемых функций, текстовый вывод ошибок и аварийное завершение.</li>
<li>Программа, разработанная в результате выполнения Лабораторной Работы 1 была модифицирована под использование devctl, кроме того были добавлены дополнительные команды self и selfCopyTo для более удобного тестирования.</li>
</ol>
</li>
<li>Программа-клиент использует ПСП, полученную для от АР, в качестве ключа для шифрования сообщения методом Вернама.<ul>
<li>Реализовано, см. функцию crypt в lab1.cpp.</li>
</ul>
</li>
<li>Все функции в исходном коде должны быть документированы в формате Doxygen, с заполнением набора полей, приведённого в примере.<ul>
<li>Все функции второй лабораторной работы (<a class="el" href="lab2_8cpp.html">lab2.cpp</a>) документированы в соответствии с требованиями.</li>
</ul>
</li>
<li>Рекомендуется применение техник защитного программирования. Грамотность и красота исходного кода учитывается как один из пунктов при оценке.<ul>
<li>Как есть. <h2>Контрольные вопросы</h2>
</li>
</ul>
</li>
</ol>
<ol type="1">
<li>Какой системный механизм QNX Neutrino лежит в основе взаимодействия клиент-АР?<ul>
<li><a href="http://www.qnx.com/developers/docs/6.5.0/index.jsp?topic=%2Fcom.qnx.doc.neutrino_getting_started%2Fs1_msg.html">Обмен сообщениями</a>.</li>
</ul>
</li>
<li>Что из себя представляет файловый дескриптор в контексте этого взаимодействия?<ul>
<li>Идентификатор менеджера ресурсов и номер соединения у самого менеджера.</li>
</ul>
</li>
<li>Какие недостатки данной реализации вы можете назвать?<ol type="a">
<li>Интерфейс не соответстует <a href="http://www.qnx.com/developers/docs/6.5.0/index.jsp?topic=%2Fcom.qnx.doc.neutrino_sys_arch%2Fresource.html">обещанию</a> "a clean and well-defined interface", если говорить про сам devctl.</li>
<li>Если говорить про саму программу, то генерация ПСП при помощи обмена сообщениями с сервером посредством devctl очень плохая идея, сам интерфейс devctl кричит о том, что его не надо так использовать. Размер сообщения devctl очень желательно должен быть фиксирован(если не использовать devctlv), что приводит либо к тому, что пересылаются лишние байты, либо к тому, что нельзя обработать файл даже сравнительно небольшого размера. Обходить эту проблему при помощи множества сообщений devctl затруднительно из-за многопоточности и из-за возможности работы с несколькими клиентами одновременно, поэтому лучше всё-таки завершать всю работу за один вызов devctl. Лучшей альтернативой использованию devctl является использование <a href="http://www.qnx.com/developers/docs/6.5.0/index.jsp?topic=%2Fcom.qnx.doc.neutrino_resmgr%2Ffsystems.html">менеджера ресурсов с файловой системой</a>, что позволило бы, например, пользователю просто открыть на чтение сразу нужный "файл" по нужному "адресу" например так <code>open("/dev/LCG/123/21/256/3", O_RDONLY)</code>, где 123, 21, 256, 3 это соответственно a, c, m, x0 - параметры ЛКМ, а размер последовательности контролируется пользователем за счёт чтения нужного числа байт, что может, в случае необходимости, быть разбито на несколько порций чтения, что потребует синхронизации при помощи RESMGR_OCB_T-&gt;offset и map'а хранящего последнее значение ЛКМ для каждого последнего offset'а и мьютекса на добавление &amp; удаление элементов map'а(из-за многопоточности).</li>
</ol>
</li>
<li>Нарисуйте диаграмму последовательности функционирования многопоточного АР<ul>
<li>Вот как это <img src="http://www.qnx.com/developers/docs/6.5.0/topic/com.qnx.doc.neutrino_resmgr/images/dispatch_layer.jpg" alt="картинка" class="inline"/>
 Но при этом функции из блока blocking function могут быть переопределены или использованы стандартные, одновременно несколько функций могут обрабатывать события за счёт неблокирующего вызова Handler function, конкретные параметры зависят от атрибутов пула потоков.</li>
</ul>
</li>
<li>Какие ограничения имеет ваша программа?<ul>
<li>Соответствие входных воздействий ТЗ. (в противном случае в ответ на собщение будет возвращено ENOSYS).</li>
<li>Не больше 50-ти клиентов, 51-ый будет ждать, пока кто-то из потоков обработки освободится. (хотя ждать не долго, ведь сообщения не большие)</li>
<li>Размер запрашиваемой строки должен быть больше нуля и меньше либо равен 4096</li>
<li>m в ЛКМ не может быть равен нулю</li>
</ul>
</li>
<li>Пройдёт ли ваша программа проверку методом fuzzing testing?<ul>
<li>Конечно!</li>
</ul>
</li>
<li>Расскажите об основных параметров пула потоков.<ul>
<li>lo_water - сколько потоков минимум всегда должны ожидать прихода пользовательского сообщения.</li>
<li>increment - Сколько потоков могут быть созданы единовременно для достижения lo_water.</li>
<li>hi_water - Максимальное количество потоков ожидающих прихода пользовательского сообщения.</li>
<li>maximum - Сколько всего одновременно может быть потоков. </li>
</ul>
</li>
</ol>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>
